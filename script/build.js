import {createRequire} from 'node:module'
import fs from 'fs'
import path from 'path'
import xtend from 'xtend'
import negate from 'negate'
import {isHidden} from 'is-hidden'
import {iso6393} from 'iso-639-3'
import {speakers} from 'speakers'
import {unified} from 'unified'
import rehypeParse from 'rehype-parse'
import gfm from 'remark-gfm'
import stringify from 'remark-stringify'
import {u} from 'unist-builder'
import {selectAll} from 'hast-util-select'
import {toText} from 'hast-util-to-text'
import format from 'format'
import author from 'parse-author'
import human from 'human-format'
import alphaSort from 'alpha-sort'
import {udhr} from 'udhr'
import allTrigrams from 'trigrams'
import unicode from 'unicode-12.1.0'
import customFixtures from './custom-fixtures.js'
import overrides from './udhr-overrides.js'
import exclude from './udhr-exclude.js'

const ascending = alphaSort()

const trigrams = allTrigrams.min()
const scripts = unicode.Script

const require = createRequire(import.meta.url)

var core = process.cwd()
var root = path.join(core, 'packages')
var mono = JSON.parse(fs.readFileSync('package.json'))

/* Persian (fas, macrolanguage) contains Western Persian (pes)
 * and Dari (prs).  They’re so similar in UDHR that using both
 * will result in incorrect results, so add the macrolanguage
 * instead. (note: prs and pes are ignored) */
speakers.fas = speakers.prs + speakers.pes

var expressions = createExpressions()
var topLanguages = createTopLanguages()
var doc = fs.readFileSync(path.join(root, 'franc', 'index.js'), 'utf8')

fs.readdirSync(root).filter(negate(isHidden)).forEach(generate)

function generate(basename) {
  var base = path.join(root, basename)
  var pack = JSON.parse(fs.readFileSync(path.join(base, 'package.json')))
  var threshold = pack.threshold
  var support = []
  var regularExpressions = {} /* Ha! */
  var perScript = {}
  var data = {}
  var list = topLanguages
  var fixtures
  var byScript

  if (!threshold) {
    return
  }

  console.log()
  console.log('%s, threshold: %s', pack.name, threshold)

  if (threshold !== -1) {
    list = list.filter(function (info) {
      return info.speakers >= threshold
    })
  }

  byScript = createTopLanguagesByScript(list)

  Object.keys(byScript).forEach(function (script) {
    var languages = byScript[script].filter(function (info) {
      return (
        [
          /* Ignore `npi` (Nepali (individual language)): `npe`
           * (Nepali (macrolanguage)) is also included. */
          'npi',
          /* Ignore non-Mandarin Chinese, if all are turned on, they’ll get
           * ignored, as trigrams don’t work on Han characters (cmn has 830m
           * speakers, so that’s the preferred choice). */
          'yue',
          'cjy',
          'gan',
          'nan',
          'wuu',
          'hak'
        ].indexOf(info.iso6393) === -1
      )
    })

    if (languages.length > 1) {
      if (!regularExpressions[script]) {
        regularExpressions[script] = expressions[script]
      }

      perScript[script] = languages
    } else {
      support.push(languages[0])
      regularExpressions[languages[0].iso6393] = expressions[script]
    }
  })

  Object.keys(perScript).forEach(function (script) {
    var scriptObject = {}

    data[script] = scriptObject

    perScript[script].forEach(function (info) {
      if (trigrams[info.udhr]) {
        support.push(info)
        scriptObject[info.iso6393] = trigrams[info.udhr]
          .concat()
          .reverse()
          .join('|')
      } else {
        console.log(
          '  Ignoring language without trigrams: %s (%s, %s)',
          info.iso6393,
          info.name,
          script
        )
      }
    })
  })

  /* Push Japanese.
   * Unicode Kanji Table from http://www.rikai.com/library/kanjitables/kanji_codes.unicode.shtml */
  var kanjiRegexSource = '[\u3400-\u4DB5\u4E00-\u9FAF]'
  regularExpressions.jpn = new RegExp(
    expressions.Hiragana.source +
      '|' +
      expressions.Katakana.source +
      '|' +
      kanjiRegexSource,
    'g'
  )

  support.sort(sort)

  fs.writeFileSync(
    path.join(base, 'expressions.js'),
    generateExpressions(regularExpressions)
  )

  fs.writeFileSync(
    path.join(base, 'data.js'),
    'const data = ' +
      JSON.stringify(data, null, 2) +
      '\n\nexport default data\n'
  )

  fs.writeFileSync(path.join(base, 'readme.md'), generateReadme(pack, support))

  if (pack.name !== mono.name) {
    fs.writeFileSync(
      path.join(base, 'index.js'),
      '// This file is generated by `build.js`\n' + doc
    )
  }

  console.log('✓ %s w/ %s languages', pack.name, list.length)

  if (pack.name !== mono.name) {
    return
  }

  console.log()
  console.log('Creating fixtures')

  fixtures = {}

  support.forEach(function (language) {
    var udhrKey = language.udhr || language.iso6393
    var fixture

    if (udhrKey in customFixtures) {
      fixture = customFixtures[udhrKey]
    } else if (udhrKey) {
      const info = udhr.find((d) => d.code === udhrKey)

      if (info) {
        const declaration = String(
          fs.readFileSync(
            path.join('node_modules', 'udhr', 'declaration', udhrKey + '.html')
          )
        )
        const tree = unified().use(rehypeParse).parse(declaration)

        fixture =
          selectAll('header p', tree)
            .map((d) => toText(d))
            .join('\n') ||
          selectAll(
            'body > :matches(h1, h2, h3, h4, h5, h6), header :matches(h1, h2, h3, h4, h5, h6)',
            tree
          )
            .map((d) => toText(d))
            .join('\n')
      }
    }

    if (!fixture) {
      console.log(
        '  Could not access preamble or note for `%s` (%s). No fixture is generated.',
        language.iso6393,
        udhrKey
      )

      fixture = ''
    }

    fixtures[udhrKey] = {
      iso6393: language.iso6393,
      fixture: fixture.slice(0, 1000)
    }
  })

  fs.writeFileSync(
    path.join(core, 'test', 'fixtures.js'),
    'const fixtures = ' +
      JSON.stringify(fixtures, null, 2) +
      '\n\nexport default fixtures\n'
  )

  console.log('✓ fixtures')
}

function generateExpressions(expressions) {
  return [
    '// This file is generated by `build.js`.',
    'const expressions = {',
    '  ' +
      Object.keys(expressions)
        .map(function (script) {
          return script + ': ' + expressions[script]
        })
        .join(',\n  '),
    '}',
    '',
    'export default expressions',
    ''
  ].join('\n')
}

function generateReadme(pack, list) {
  var counts = count(list)
  var threshold = pack.threshold
  var licensee = author(pack.author)
  var tree = u('root', [
    u('html', '<!--This file is generated by `build.js`-->'),
    u('heading', {depth: 1}, [u('text', pack.name)]),
    u('blockquote', [u('paragraph', [u('text', pack.description + '.')])]),
    u('paragraph', [
      u(
        'text',
        format(
          'Built with support for %s languages%s.',
          list.length,
          threshold === -1
            ? ''
            : ' (' + human(threshold, {separator: ''}) + ' or more speakers)'
        )
      )
    ]),
    u('paragraph', [
      u('text', 'View the '),
      u('link', {url: mono.repository}, [u('text', 'monorepo')]),
      u('text', ' for more packages and\nusage information.')
    ]),
    u('heading', {depth: 2}, [u('text', 'Install')]),
    u('paragraph', [u('text', 'npm:')]),
    u('code', {lang: 'sh'}, 'npm install ' + pack.name),
    u('heading', {depth: 2}, [u('text', 'Support')]),
    u('paragraph', [u('text', 'This build supports the following languages:')]),
    u('table', {align: []}, [header()].concat(list.map(row))),
    u('heading', {depth: 2}, [u('text', 'License')]),
    u('paragraph', [
      u('link', {url: mono.repository + '/blob/main/license'}, [
        u('text', mono.license)
      ]),
      u('text', ' © '),
      u('link', {url: licensee.url}, [u('text', licensee.name)])
    ])
  ])

  return unified().use(stringify).use(gfm).stringify(tree)

  function row(info) {
    return u('tableRow', [
      u('tableCell', [
        u(
          'link',
          {
            url:
              'http://www-01.sil.org/iso639-3/documentation.asp?id=' +
              info.iso6393,
            title: null
          },
          [u('inlineCode', info.iso6393)]
        )
      ]),
      u('tableCell', [
        u(
          'text',
          info.name +
            (counts[info.iso6393] === 1 ? '' : ' (' + info.script + ')')
        )
      ]),
      u('tableCell', [
        u(
          'text',
          isNaN(info.speakers)
            ? 'unknown'
            : human(info.speakers, {separator: '', decimals: 0})
        )
      ])
    ])
  }

  function header() {
    return u('tableRow', [
      u('tableCell', [u('text', 'Code')]),
      u('tableCell', [u('text', 'Name')]),
      u('tableCell', [u('text', 'Speakers')])
    ])
  }
}

function count(list) {
  var map = {}
  list.forEach(function (info) {
    map[info.iso6393] = (map[info.iso6393] || 0) + 1
  })
  return map
}

/* Get which scripts are used for a given UDHR code. */
function scriptInformation(code) {
  const info = code ? udhr.find((d) => d.code === code) : undefined
  let paragraphs = ''

  if (info) {
    const declaration = fs.readFileSync(
      path.join('node_modules', 'udhr', 'declaration', code + '.html')
    )
    const tree = unified().use(rehypeParse).parse(declaration)
    paragraphs = selectAll('article p', tree)
      .map((d) => toText(d))
      .join('\n')
  }

  var length = paragraphs.length
  var scriptInformation = {}

  Object.keys(expressions).forEach(function (script) {
    var count

    /* Ignore: unimportant for our goal, scripts. */
    if (script === 'Common' || script === 'Inherited') {
      return
    }

    count = paragraphs.match(expressions[script])
    count = (count ? count.length : 0) / length
    count = Math.round(count * 100) / 100

    if (count && count > 0.05) {
      scriptInformation[script] = count
    }
  })

  return scriptInformation
}

/* Sort a list of languages by most-popular. */
function sort(a, b) {
  return (
    (b.speakers || 0) - (a.speakers || 0) ||
    ascending(a.name, b.name) ||
    ascending(a.script, b.script)
  )
}

function createExpressions() {
  var result = {}
  scripts.forEach(function (script) {
    var expression = require('unicode-12.1.0/Script/' + script + '/regex.js')
    result[script] = new RegExp(expression.source, 'g')
  })
  return result
}

function createTopLanguages() {
  var top = iso6393
    .map(function (info) {
      return xtend(info, {speakers: speakers[info.iso6393]})
    })
    .filter(function (info) {
      var code = info.iso6393
      var name = info.name

      if (exclude.indexOf(code) !== -1) {
        console.log('Ignoring unsafe language `%s` (%s)', code, name)
        return false
      }

      if (info.type === 'special') {
        console.log('Ignoring special code `%s` (%s)', code, name)
        return false
      }

      return true
    })

  top.forEach(function (info) {
    var code = info.iso6393
    var udhrs = getUDHRKeysfromISO(code)

    info.udhr = udhrs.pop()

    if (udhrs.length !== 0) {
      udhrs.forEach(function (udhr) {
        top.push(xtend(info, {udhr: udhr}))
      })
    }
  })

  top.forEach(function (info) {
    var code = info.iso6393
    var scripts = scriptInformation(info.udhr)

    /* Languages without (accessible) UDHR declaration.
     * No trigram, and no custom script, available for:
     * - awa (Awadhi): Devanagari, Kaithi, Persian;
     * - snd (Sindhi): Arabic, Devanagari, Khudabadi, and more;
     * - hne (Chhattisgarhi): Devanagari;
     * - asm (Assamese): Assamese (Bengali + two other characters*);
     * - koi (Komi-Permyak): Cyrillic;
     * - raj (Rajasthani): Devanagari;
     * - mve (Marwari): Devanagari, and Mahajani (which is in unicode*);
     * - bjj (Kanauji): Devanagari;
     * - kmr (Northern Kurdish): Latin (main); Perso-Arabic;
     * - kas (Kashmiri): Perso-Arabic, Devanagari, Sharada.
     * - shn (Shan): A Shan script exists, but nearly no one can read it*.
     * - gbm (Garhwali): Devanagari
     * - dyu (Dyula): N'Ko, Latin, Arabic
     * - ksw (S'gaw Karen): Burmese
     * - gno (Northern Gondi): Devanagari, Telugu
     * - bgp (Eastern Balochi): Urdu Arabic, Arabic
     * - unr (Mundari): ?
     * - hoc (Ho): Ol Chiki, Devanagari, Varang Kshiti
     * - pwo (Pwo Western Karen): Burmese
     *
     * *: future interest?
     */
    if (code === 'tel') {
      scripts.Telugu = 0.8
    } else if (code === 'ori') {
      scripts.Oriya = 0.8
    } else if (code === 'sin') {
      scripts.Sinhala = 0.8
    } else if (code === 'sat') {
      scripts.Ol_Chiki = 0.8
    } else if (code === 'jpn') {
      /* Japanese is different. */
      scripts = {'Hiragana, Katakana, and Han': 0.8}
    }

    info.script = Object.keys(scripts)
  })

  top = top.filter(function (info) {
    var scripts = info.script
    var ignore = !trigrams[info.udhr] && scripts.length === 0

    info.script = scripts[0]

    if (scripts.length > 1) {
      throw new Error(
        'Woops, I found a language which uses more than one script. Franc is not build for that. Exiting.'
      )
    }

    if (ignore && info.speakers && info.speakers > 1e6) {
      console.log(
        'Ignoring language with neither trigrams nor scripts: %s (%s, %s)',
        info.iso6393,
        info.name,
        info.speakers
      )
    }

    return !ignore
  })

  return top.sort(sort)
}

function createTopLanguagesByScript(top) {
  var scripts = {}

  top.forEach(function (info) {
    var script = info.script

    if (!scripts[script]) {
      scripts[script] = []
    }

    scripts[script].push(info)
  })

  return scripts
}

/* Get UDHR codes for an ISO6393 code. */
function getUDHRKeysfromISO(iso) {
  var udhrs = []

  if (iso in overrides) {
    return overrides[iso]
  }

  udhr.forEach(function (info) {
    if (info.iso6393 === iso || info.code === iso) {
      udhrs.push(info.code)
    }
  })

  if (udhrs.length === 1) {
    return udhrs
  }

  /* Pick the main UDHR. */
  if (udhrs.indexOf(iso) !== -1) {
    return [iso]
  }

  return udhrs
}
